[
  {
    "questionId": "cpp_h_1",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the main purpose of RAII in C++?",
    "options": [
      "Speed optimization",
      "Automatic resource management",
      "Thread synchronization",
      "Memory alignment"
    ],
    "answer": "Automatic resource management",
    "reason": "RAII ties resource lifetime to object lifetime, ensuring deterministic cleanup."
  },
  {
    "questionId": "cpp_h_2",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What happens if a destructor throws an exception during stack unwinding?",
    "options": [
      "Exception is ignored",
      "Program terminates",
      "Destructor retries",
      "Undefined behavior"
    ],
    "answer": "Program terminates",
    "reason": "Throwing during stack unwinding triggers std::terminate."
  },
  {
    "questionId": "cpp_h_3",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does the 'mutable' keyword allow?",
    "options": [
      "Thread safety",
      "Modification inside const objects",
      "Inheritance override",
      "Heap allocation"
    ],
    "answer": "Modification inside const objects",
    "reason": "mutable allows a member to be modified even in const contexts."
  },
  {
    "questionId": "cpp_h_4",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is deleting through a base pointer without virtual destructor dangerous?",
    "options": [
      "Memory leak",
      "Undefined behavior",
      "Double free",
      "Stack overflow"
    ],
    "answer": "Undefined behavior",
    "reason": "Derived destructor may not be called, causing UB."
  },
  {
    "questionId": "cpp_h_5",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does std::move actually do?",
    "options": [
      "Moves memory",
      "Copies object",
      "Casts to rvalue reference",
      "Deletes source"
    ],
    "answer": "Casts to rvalue reference",
    "reason": "std::move enables move semantics by casting."
  },
  {
    "questionId": "cpp_h_6",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Which rule governs special member function generation?",
    "options": [
      "Rule of Zero",
      "Rule of Five",
      "Rule of Three",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "Each rule applies depending on class design."
  },
  {
    "questionId": "cpp_h_7",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is type erasure used for?",
    "options": [
      "Compile-time polymorphism",
      "Runtime polymorphism without inheritance",
      "Memory optimization",
      "Template specialization"
    ],
    "answer": "Runtime polymorphism without inheritance",
    "reason": "Type erasure hides concrete types behind a uniform interface."
  },
  {
    "questionId": "cpp_h_8",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is std::vector not thread-safe?",
    "options": [
      "Iterator invalidation",
      "Lack of mutex",
      "Data races on modification",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "Concurrent access without synchronization causes data races."
  },
  {
    "questionId": "cpp_h_9",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does the volatile keyword guarantee?",
    "options": [
      "Atomicity",
      "Thread safety",
      "No optimization on access",
      "Memory ordering"
    ],
    "answer": "No optimization on access",
    "reason": "volatile prevents certain compiler optimizations only."
  },
  {
    "questionId": "cpp_h_10",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is undefined behavior?",
    "options": [
      "Compile error",
      "Runtime exception",
      "Behavior not defined by standard",
      "OS-specific behavior"
    ],
    "answer": "Behavior not defined by standard",
    "reason": "UB allows compilers to assume it never happens."
  },
  {
    "questionId": "cpp_h_11",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why are iterators invalidated after vector reallocation?",
    "options": [
      "Memory freed",
      "Capacity change",
      "Elements moved",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "Reallocation relocates storage, invalidating references."
  },
  {
    "questionId": "cpp_h_12",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the diamond problem?",
    "options": [
      "Multiple inheritance ambiguity",
      "Memory alignment issue",
      "Template recursion",
      "Virtual dispatch failure"
    ],
    "answer": "Multiple inheritance ambiguity",
    "reason": "Virtual inheritance resolves duplicate base subobjects."
  },
  {
    "questionId": "cpp_h_13",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does constexpr enable?",
    "options": [
      "Runtime optimization",
      "Compile-time evaluation",
      "Thread safety",
      "Inlining"
    ],
    "answer": "Compile-time evaluation",
    "reason": "constexpr allows expressions to be evaluated at compile time."
  },
  {
    "questionId": "cpp_h_14",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is reinterpret_cast dangerous?",
    "options": [
      "Syntax complexity",
      "Breaks type safety",
      "Slower execution",
      "Memory leaks"
    ],
    "answer": "Breaks type safety",
    "reason": "reinterpret_cast performs unchecked conversions."
  },
  {
    "questionId": "cpp_h_15",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is false sharing?",
    "options": [
      "Incorrect pointer sharing",
      "Cache line contention",
      "Memory leak",
      "Deadlock"
    ],
    "answer": "Cache line contention",
    "reason": "Threads modify different variables on the same cache line."
  },
  {
    "questionId": "cpp_h_16",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What problem does std::atomic solve?",
    "options": ["Deadlocks", "Data races", "Memory leaks", "Cache misses"],
    "answer": "Data races",
    "reason": "Atomic operations ensure safe concurrent access."
  },
  {
    "questionId": "cpp_h_17",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is SFINAE?",
    "options": [
      "Template instantiation rule",
      "Compiler optimization",
      "Memory model",
      "Linker behavior"
    ],
    "answer": "Template instantiation rule",
    "reason": "Substitution Failure Is Not An Error removes invalid overloads."
  },
  {
    "questionId": "cpp_h_18",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why are dangling references dangerous?",
    "options": [
      "Memory corruption",
      "Compilation error",
      "Performance drop",
      "Thread starvation"
    ],
    "answer": "Memory corruption",
    "reason": "They refer to destroyed objects."
  },
  {
    "questionId": "cpp_h_19",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does noexcept affect?",
    "options": [
      "Optimization",
      "Exception propagation",
      "Move semantics",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "noexcept influences optimization and exception guarantees."
  },
  {
    "questionId": "cpp_h_20",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the main cost of virtual functions?",
    "options": [
      "Extra memory",
      "Indirect call overhead",
      "Cache miss",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "Virtual dispatch introduces indirection and vtable storage."
  },
  {
    "questionId": "cpp_h_21",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does the C++ memory model define?",
    "options": [
      "Heap allocation strategy",
      "Thread scheduling",
      "Rules for atomic operations and visibility",
      "Garbage collection"
    ],
    "answer": "Rules for atomic operations and visibility",
    "reason": "The memory model specifies how operations are ordered across threads."
  },
  {
    "questionId": "cpp_h_22",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is std::unique_ptr non-copyable?",
    "options": [
      "Performance reasons",
      "To enforce exclusive ownership",
      "Memory alignment",
      "Compiler limitation"
    ],
    "answer": "To enforce exclusive ownership",
    "reason": "unique_ptr represents sole ownership of a resource."
  },
  {
    "questionId": "cpp_h_23",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the effect of memory_order_relaxed?",
    "options": [
      "Sequential consistency",
      "No ordering guarantees",
      "Full memory fence",
      "Thread blocking"
    ],
    "answer": "No ordering guarantees",
    "reason": "It only guarantees atomicity, not ordering."
  },
  {
    "questionId": "cpp_h_24",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What problem does the ABA issue relate to?",
    "options": [
      "Deadlocks",
      "Lock-free algorithms",
      "Virtual dispatch",
      "Template recursion"
    ],
    "answer": "Lock-free algorithms",
    "reason": "ABA occurs when a value changes and changes back unnoticed."
  },
  {
    "questionId": "cpp_h_25",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why should base class destructors usually be virtual?",
    "options": [
      "Performance",
      "Correct polymorphic deletion",
      "Inlining",
      "Memory layout"
    ],
    "answer": "Correct polymorphic deletion",
    "reason": "Ensures derived destructors are invoked."
  },
  {
    "questionId": "cpp_h_26",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does std::launder address?",
    "options": [
      "Memory leaks",
      "Pointer aliasing rules",
      "Thread synchronization",
      "Cache invalidation"
    ],
    "answer": "Pointer aliasing rules",
    "reason": "It allows accessing objects created via placement new."
  },
  {
    "questionId": "cpp_h_27",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is std::shared_ptr slower than std::unique_ptr?",
    "options": [
      "Extra heap allocation",
      "Reference counting overhead",
      "Virtual dispatch",
      "Larger object size"
    ],
    "answer": "Reference counting overhead",
    "reason": "Atomic reference count updates add cost."
  },
  {
    "questionId": "cpp_h_28",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does alignment affect?",
    "options": [
      "Correctness only",
      "Performance and correctness",
      "Only memory size",
      "Only compilation"
    ],
    "answer": "Performance and correctness",
    "reason": "Misaligned access may be slower or undefined."
  },
  {
    "questionId": "cpp_h_29",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is ODR (One Definition Rule)?",
    "options": [
      "Single header rule",
      "Only one definition across program",
      "Inline enforcement",
      "Template specialization rule"
    ],
    "answer": "Only one definition across program",
    "reason": "Violating ODR leads to undefined behavior."
  },
  {
    "questionId": "cpp_h_30",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is std::vector preferred over raw arrays?",
    "options": [
      "Faster access",
      "Automatic memory management",
      "Thread safety",
      "Stack allocation"
    ],
    "answer": "Automatic memory management",
    "reason": "vector handles allocation, resizing, and destruction safely."
  },

  {
    "questionId": "cpp_h_31",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is strict aliasing?",
    "options": [
      "Pointer lifetime rule",
      "Type-based aliasing rule",
      "Const correctness",
      "Template instantiation rule"
    ],
    "answer": "Type-based aliasing rule",
    "reason": "Violating it allows compilers to optimize aggressively."
  },
  {
    "questionId": "cpp_h_32",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the cost of false sharing?",
    "options": [
      "Increased cache coherence traffic",
      "Extra heap usage",
      "More system calls",
      "Stack overflow"
    ],
    "answer": "Increased cache coherence traffic",
    "reason": "Threads compete on the same cache line."
  },
  {
    "questionId": "cpp_h_33",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is placement new useful?",
    "options": [
      "Heap allocation",
      "Manual memory control",
      "Automatic GC",
      "Thread safety"
    ],
    "answer": "Manual memory control",
    "reason": "It constructs objects in pre-allocated memory."
  },
  {
    "questionId": "cpp_h_34",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does constexpr constructor enable?",
    "options": [
      "Runtime optimization",
      "Compile-time object creation",
      "Thread safety",
      "Inlining"
    ],
    "answer": "Compile-time object creation",
    "reason": "Allows objects to exist in constant expressions."
  },
  {
    "questionId": "cpp_h_35",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why are data races undefined behavior?",
    "options": [
      "Compiler simplicity",
      "Hardware dependency",
      "Optimization freedom",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "Undefined behavior enables aggressive optimizations."
  },

  {
    "questionId": "cpp_h_36",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the purpose of std::memory_order_acquire?",
    "options": [
      "Prevent reordering after load",
      "Prevent reordering before store",
      "Full memory fence",
      "Atomic increment"
    ],
    "answer": "Prevent reordering after load",
    "reason": "Acquire ensures subsequent reads see prior writes."
  },
  {
    "questionId": "cpp_h_37",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is cache locality?",
    "options": [
      "Thread scheduling",
      "Memory alignment",
      "Accessing nearby memory locations",
      "Heap optimization"
    ],
    "answer": "Accessing nearby memory locations",
    "reason": "Improves performance due to cache behavior."
  },
  {
    "questionId": "cpp_h_38",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is std::function slower than templates?",
    "options": [
      "Heap allocation",
      "Type erasure overhead",
      "Virtual dispatch",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "std::function uses type erasure internally."
  },
  {
    "questionId": "cpp_h_39",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the primary risk of multiple inheritance?",
    "options": [
      "Memory leaks",
      "Ambiguous base subobjects",
      "Stack overflow",
      "Slower compilation"
    ],
    "answer": "Ambiguous base subobjects",
    "reason": "Diamond inheritance causes ambiguity."
  },
  {
    "questionId": "cpp_h_40",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is noexcept important for move constructors?",
    "options": [
      "Correctness",
      "Container optimization",
      "Thread safety",
      "Inlining"
    ],
    "answer": "Container optimization",
    "reason": "STL containers prefer noexcept moves."
  },

  {
    "questionId": "cpp_h_41",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does std::scoped_lock prevent?",
    "options": ["Memory leaks", "Deadlocks", "Data races", "False sharing"],
    "answer": "Deadlocks",
    "reason": "It locks multiple mutexes safely."
  },
  {
    "questionId": "cpp_h_42",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the cost of virtual inheritance?",
    "options": [
      "Extra indirection",
      "Larger object size",
      "More complex construction",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "Virtual bases add runtime overhead."
  },

  {
    "questionId": "cpp_h_43",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is memcpy unsafe for non-trivial types?",
    "options": [
      "Alignment issues",
      "Breaks object invariants",
      "Slower performance",
      "Compiler error"
    ],
    "answer": "Breaks object invariants",
    "reason": "Non-trivial types require constructors."
  },

  {
    "questionId": "cpp_h_44",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What is the benefit of small object optimization?",
    "options": [
      "Avoid heap allocation",
      "Faster compilation",
      "Lower memory usage",
      "Thread safety"
    ],
    "answer": "Avoid heap allocation",
    "reason": "Small objects are stored inline."
  },

  {
    "questionId": "cpp_h_45",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does std::bit_cast require?",
    "options": [
      "Same size types",
      "Same alignment",
      "Same type",
      "Inheritance"
    ],
    "answer": "Same size types",
    "reason": "bit_cast copies raw representation safely."
  },

  {
    "questionId": "cpp_h_46",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is undefined behavior dangerous?",
    "options": [
      "Crashes only",
      "Security vulnerabilities",
      "Unpredictable execution",
      "All of the above"
    ],
    "answer": "All of the above",
    "reason": "UB allows arbitrary compiler assumptions."
  },

  {
    "questionId": "cpp_h_47",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does std::span represent?",
    "options": [
      "Owning container",
      "Non-owning view",
      "Thread-safe array",
      "Dynamic allocation"
    ],
    "answer": "Non-owning view",
    "reason": "span provides bounds-safe access without ownership."
  },

  {
    "questionId": "cpp_h_48",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why should destructors not throw?",
    "options": [
      "Performance",
      "Stack unwinding termination",
      "Inlining issues",
      "Memory leaks"
    ],
    "answer": "Stack unwinding termination",
    "reason": "Throwing causes std::terminate."
  },

  {
    "questionId": "cpp_h_49",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "What does lock-free guarantee?",
    "options": [
      "No deadlocks",
      "Progress without blocking",
      "Wait-free execution",
      "Thread priority"
    ],
    "answer": "Progress without blocking",
    "reason": "Lock-free ensures at least one thread makes progress."
  },

  {
    "questionId": "cpp_h_50",
    "topic": "c++",
    "difficulty": "hard",
    "questionText": "Why is reinterpret_cast rarely recommended?",
    "options": ["Slow", "Unsafe", "Verbose", "Deprecated"],
    "answer": "Unsafe",
    "reason": "It bypasses type safety."
  },
  {
    "questionId": "cpp_h_51",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is undefined behavior when accessing a vector out of bounds using operator[]?",
    "options": [
      "Exception thrown",
      "Returns default value",
      "Undefined behavior",
      "Program stops"
    ],
    "answer": "Undefined behavior",
    "reason": "operator[] does not perform bounds checking in std::vector."
  },
  {
    "questionId": "cpp_h_52",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What happens if delete is used on memory allocated with malloc?",
    "options": [
      "Safe operation",
      "Memory leak",
      "Undefined behavior",
      "Compile error"
    ],
    "answer": "Undefined behavior",
    "reason": "Memory allocated with malloc must be freed using free."
  },
  {
    "questionId": "cpp_h_53",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does the volatile keyword guarantee?",
    "options": [
      "Thread safety",
      "No optimization",
      "Atomic access",
      "Cache coherency"
    ],
    "answer": "No optimization",
    "reason": "volatile prevents certain compiler optimizations but does not ensure thread safety."
  },
  {
    "questionId": "cpp_h_54",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which STL container guarantees iterator validity on insert?",
    "options": ["vector", "deque", "list", "unordered_map"],
    "answer": "list",
    "reason": "std::list iterators remain valid after insertions."
  },
  {
    "questionId": "cpp_h_55",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is the result of deleting a base class pointer without virtual destructor?",
    "options": [
      "Safe destruction",
      "Only base destructor called",
      "Memory leak",
      "Undefined behavior"
    ],
    "answer": "Undefined behavior",
    "reason": "Deleting through base pointer requires a virtual destructor."
  },
  {
    "questionId": "cpp_h_56",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does std::move actually do?",
    "options": [
      "Moves memory",
      "Copies object",
      "Casts to rvalue reference",
      "Deletes object"
    ],
    "answer": "Casts to rvalue reference",
    "reason": "std::move enables move semantics by casting to rvalue reference."
  },
  {
    "questionId": "cpp_h_57",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which situation causes data race?",
    "options": [
      "Two reads",
      "Read and write without sync",
      "Two writes with mutex",
      "Atomic access"
    ],
    "answer": "Read and write without sync",
    "reason": "Data races occur when concurrent unsynchronized read/write happens."
  },
  {
    "questionId": "cpp_h_58",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is the main purpose of std::enable_if?",
    "options": [
      "Runtime check",
      "Template specialization",
      "SFINAE control",
      "Type casting"
    ],
    "answer": "SFINAE control",
    "reason": "enable_if conditionally enables template instantiation."
  },
  {
    "questionId": "cpp_h_59",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What happens if a mutex is locked twice by the same thread?",
    "options": ["Safe", "Deadlock", "Exception", "Undefined behavior"],
    "answer": "Deadlock",
    "reason": "std::mutex is non-recursive by default."
  },
  {
    "questionId": "cpp_h_60",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which cast is safest for downcasting polymorphic types?",
    "options": [
      "static_cast",
      "reinterpret_cast",
      "dynamic_cast",
      "const_cast"
    ],
    "answer": "dynamic_cast",
    "reason": "dynamic_cast performs runtime type checking."
  },
  {
    "questionId": "cpp_h_61",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is the lifetime of a temporary object bound to const reference?",
    "options": [
      "Until end of scope",
      "Until statement end",
      "Until function end",
      "Undefined"
    ],
    "answer": "Until end of scope",
    "reason": "Binding to const reference extends temporary lifetime."
  },
  {
    "questionId": "cpp_h_62",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which container offers average O(1) lookup?",
    "options": ["map", "set", "unordered_map", "vector"],
    "answer": "unordered_map",
    "reason": "Hash tables provide average constant-time lookup."
  },
  {
    "questionId": "cpp_h_63",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does noexcept affect?",
    "options": [
      "Compilation",
      "Inlining",
      "Exception guarantees",
      "Memory layout"
    ],
    "answer": "Exception guarantees",
    "reason": "noexcept indicates a function will not throw exceptions."
  },
  {
    "questionId": "cpp_h_64",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which causes undefined behavior?",
    "options": [
      "Deleting nullptr",
      "Reading uninitialized variable",
      "Calling empty function",
      "Returning value"
    ],
    "answer": "Reading uninitialized variable",
    "reason": "Accessing uninitialized data is undefined behavior."
  },
  {
    "questionId": "cpp_h_65",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does placement new do?",
    "options": [
      "Allocates memory",
      "Calls constructor at address",
      "Moves object",
      "Deletes memory"
    ],
    "answer": "Calls constructor at address",
    "reason": "Placement new constructs object at a given memory location."
  },
  {
    "questionId": "cpp_h_66",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is the rule of five?",
    "options": [
      "Five constructors",
      "Memory rule",
      "Special member functions",
      "Inheritance rule"
    ],
    "answer": "Special member functions",
    "reason": "It refers to copy/move constructors and assignment operators plus destructor."
  },
  {
    "questionId": "cpp_h_67",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What happens if std::thread object is destroyed while joinable?",
    "options": [
      "Thread detaches",
      "Thread joins",
      "Program terminates",
      "Undefined behavior"
    ],
    "answer": "Program terminates",
    "reason": "Destroying a joinable thread calls std::terminate."
  },
  {
    "questionId": "cpp_h_68",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is the purpose of std::launder?",
    "options": [
      "Memory cleanup",
      "Pointer optimization",
      "Access reused storage",
      "Thread safety"
    ],
    "answer": "Access reused storage",
    "reason": "std::launder allows accessing objects in reused memory."
  },
  {
    "questionId": "cpp_h_69",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which operation invalidates vector iterators?",
    "options": ["push_back", "reserve", "clear", "All of above"],
    "answer": "All of above",
    "reason": "These operations may reallocate memory or invalidate iterators."
  },
  {
    "questionId": "cpp_h_70",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is false sharing?",
    "options": [
      "Invalid cache",
      "Shared pointer bug",
      "Cache line contention",
      "Thread deadlock"
    ],
    "answer": "Cache line contention",
    "reason": "False sharing happens when threads modify nearby memory on same cache line."
  },
  {
    "questionId": "cpp_h_71",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does std::atomic guarantee?",
    "options": [
      "Lock-free always",
      "Atomic operations",
      "No race conditions",
      "Memory safety"
    ],
    "answer": "Atomic operations",
    "reason": "std::atomic ensures atomic read/write operations."
  },
  {
    "questionId": "cpp_h_72",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which memory order is strongest?",
    "options": ["relaxed", "consume", "acquire", "seq_cst"],
    "answer": "seq_cst",
    "reason": "Sequential consistency provides strongest ordering guarantees."
  },
  {
    "questionId": "cpp_h_73",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does inline keyword guarantee?",
    "options": [
      "Inline expansion",
      "No multiple definitions",
      "Optimization hint",
      "Stack allocation"
    ],
    "answer": "No multiple definitions",
    "reason": "inline allows multiple definitions across translation units."
  },
  {
    "questionId": "cpp_h_74",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which is UB?",
    "options": [
      "Deleting nullptr",
      "Double delete",
      "Using std::unique_ptr",
      "Calling destructor"
    ],
    "answer": "Double delete",
    "reason": "Deleting the same memory twice causes undefined behavior."
  },
  {
    "questionId": "cpp_h_75",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does std::future represent?",
    "options": ["Thread", "Deferred value", "Mutex", "Promise only"],
    "answer": "Deferred value",
    "reason": "std::future holds a value available later."
  },
  {
    "questionId": "cpp_h_76",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which type trait checks inheritance?",
    "options": ["is_base_of", "is_convertible", "is_same", "is_polymorphic"],
    "answer": "is_base_of",
    "reason": "std::is_base_of checks class inheritance relationship."
  },
  {
    "questionId": "cpp_h_77",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is strict aliasing rule?",
    "options": [
      "Type conversion rule",
      "Pointer alias rule",
      "Memory allocation",
      "Thread safety"
    ],
    "answer": "Pointer alias rule",
    "reason": "Strict aliasing defines how different pointer types may alias memory."
  },
  {
    "questionId": "cpp_h_78",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which smart pointer allows shared ownership?",
    "options": ["unique_ptr", "shared_ptr", "weak_ptr", "auto_ptr"],
    "answer": "shared_ptr",
    "reason": "shared_ptr maintains reference counting."
  },
  {
    "questionId": "cpp_h_79",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What causes std::bad_alloc?",
    "options": [
      "Stack overflow",
      "Heap allocation failure",
      "Null pointer",
      "Logic error"
    ],
    "answer": "Heap allocation failure",
    "reason": "std::bad_alloc is thrown when memory allocation fails."
  },
  {
    "questionId": "cpp_h_80",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is ABI?",
    "options": [
      "API layer",
      "Binary interface",
      "Compiler flag",
      "Linker rule"
    ],
    "answer": "Binary interface",
    "reason": "ABI defines binary-level compatibility."
  },
  {
    "questionId": "cpp_h_81",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which feature enables compile-time computation?",
    "options": ["constexpr", "inline", "macro", "typedef"],
    "answer": "constexpr",
    "reason": "constexpr allows evaluation at compile time."
  },
  {
    "questionId": "cpp_h_82",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does std::weak_ptr prevent?",
    "options": [
      "Dangling pointer",
      "Data race",
      "Circular reference",
      "Double delete"
    ],
    "answer": "Circular reference",
    "reason": "weak_ptr breaks shared_ptr reference cycles."
  },
  {
    "questionId": "cpp_h_83",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What happens when exception escapes destructor?",
    "options": ["Ignored", "Logged", "std::terminate", "Undefined behavior"],
    "answer": "std::terminate",
    "reason": "Throwing from destructor during stack unwinding terminates program."
  },
  {
    "questionId": "cpp_h_84",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does ODR stand for?",
    "options": [
      "Object Definition Rule",
      "One Definition Rule",
      "Optimized Data Rule",
      "Overload Definition Rule"
    ],
    "answer": "One Definition Rule",
    "reason": "ODR ensures entities have exactly one definition."
  },
  {
    "questionId": "cpp_h_85",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which is not lock-free guarantee?",
    "options": ["atomic<int>", "mutex", "atomic_flag", "atomic<bool>"],
    "answer": "mutex",
    "reason": "mutex is blocking, not lock-free."
  },
  {
    "questionId": "cpp_h_86",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is type erasure used for?",
    "options": [
      "Remove templates",
      "Runtime polymorphism",
      "Memory cleanup",
      "Inlining"
    ],
    "answer": "Runtime polymorphism",
    "reason": "Type erasure hides concrete types behind uniform interfaces."
  },
  {
    "questionId": "cpp_h_87",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which keyword enforces memory visibility between threads?",
    "options": ["volatile", "atomic", "mutable", "register"],
    "answer": "atomic",
    "reason": "atomic ensures memory visibility and synchronization."
  },
  {
    "questionId": "cpp_h_88",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is CRTP?",
    "options": [
      "Compile-time recursion",
      "Static polymorphism",
      "Dynamic dispatch",
      "Template specialization"
    ],
    "answer": "Static polymorphism",
    "reason": "CRTP enables polymorphism at compile time."
  },
  {
    "questionId": "cpp_h_89",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which container is cache-friendly?",
    "options": ["list", "map", "vector", "set"],
    "answer": "vector",
    "reason": "vector stores elements contiguously."
  },
  {
    "questionId": "cpp_h_90",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is the purpose of alignas?",
    "options": [
      "Type conversion",
      "Memory alignment",
      "Thread safety",
      "Inlining"
    ],
    "answer": "Memory alignment",
    "reason": "alignas specifies alignment requirements."
  },
  {
    "questionId": "cpp_h_91",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which causes stack unwinding?",
    "options": ["Return", "Throw exception", "Break", "Goto"],
    "answer": "Throw exception",
    "reason": "Exceptions trigger stack unwinding."
  },
  {
    "questionId": "cpp_h_92",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does std::scoped_lock prevent?",
    "options": [
      "Deadlock",
      "Race condition",
      "Memory leak",
      "Undefined behavior"
    ],
    "answer": "Deadlock",
    "reason": "scoped_lock locks multiple mutexes safely."
  },
  {
    "questionId": "cpp_h_93",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is the main drawback of macros?",
    "options": ["Slow", "No type safety", "Memory leak", "Runtime cost"],
    "answer": "No type safety",
    "reason": "Macros are text substitution without type checking."
  },
  {
    "questionId": "cpp_h_94",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which is UB?",
    "options": [
      "Accessing freed memory",
      "Using std::vector",
      "Deleting nullptr",
      "Calling empty lambda"
    ],
    "answer": "Accessing freed memory",
    "reason": "Use-after-free is undefined behavior."
  },
  {
    "questionId": "cpp_h_95",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is memory fence?",
    "options": [
      "Heap allocator",
      "Synchronization barrier",
      "Cache flush",
      "Mutex"
    ],
    "answer": "Synchronization barrier",
    "reason": "Memory fences enforce ordering of memory operations."
  },
  {
    "questionId": "cpp_h_96",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does std::promise do?",
    "options": [
      "Creates thread",
      "Sets future value",
      "Locks mutex",
      "Manages memory"
    ],
    "answer": "Sets future value",
    "reason": "promise provides a value to a future."
  },
  {
    "questionId": "cpp_h_97",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "Which optimization may break strict aliasing?",
    "options": [
      "Inlining",
      "Loop unrolling",
      "Type punning",
      "Dead code elimination"
    ],
    "answer": "Type punning",
    "reason": "Type punning violates strict aliasing rules."
  },
  {
    "questionId": "cpp_h_98",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What does std::byte represent?",
    "options": ["Character", "Raw memory", "Integer", "Boolean"],
    "answer": "Raw memory",
    "reason": "std::byte represents raw memory without arithmetic meaning."
  },
  {
    "questionId": "cpp_h_99",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is the main cost of virtual functions?",
    "options": ["Memory", "Cache miss", "Indirect call", "Compilation time"],
    "answer": "Indirect call",
    "reason": "Virtual dispatch uses indirect function calls."
  },
  {
    "questionId": "cpp_h_100",
    "topic": "cpp",
    "difficulty": "hard",
    "questionText": "What is undefined behavior sanitizer used for?",
    "options": ["Performance", "Detect UB", "Memory allocation", "Threading"],
    "answer": "Detect UB",
    "reason": "UBSan detects undefined behavior at runtime."
  }
]
